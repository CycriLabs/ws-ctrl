#!/usr/bin/env node
import{Command as re}from"commander";var D={name:"@cycrilabs/ws-ctrl",version:"0.0.1",description:"CLI tool to initialize a development workspace",repository:{type:"git",url:"git+https://github.com/CycriLabs/ws-ctrl.git"},author:"Marc Scheib",license:"MIT",bugs:{url:"https://github.com/CycriLabs/ws-ctrl/issues"},homepage:"https://github.com/CycriLabs/ws-ctrl#readme",files:["dist"],bin:{"@cycrilabs/ws-ctrl":"dist/index.js"},type:"module",engines:{node:">=20"},scripts:{dev:"tsx src/index.ts",lint:"eslint ./src",test:"vitest","test:coverage":"vitest run --coverage",build:"tsup","build:watch":"tsup --watch",release:"npx --yes -p @semantic-release/changelog -p @semantic-release/git semantic-release",prepare:"husky"},devDependencies:{"@commitlint/cli":"^19.6.1","@commitlint/config-conventional":"^19.6.0","@eslint/js":"^9.19.0","@types/prompts":"^2.4.9","@vitest/coverage-v8":"^3.0.4",eslint:"^9.19.0",globals:"^15.14.0",husky:"^9.1.7","lint-staged":"^15.4.2",memfs:"^4.17.0",prettier:"^3.4.2",tempy:"^3.1.0",tsup:"^8.3.5",tsx:"^4.19.2",typescript:"^5.7.3","typescript-eslint":"^8.21.0",vitest:"^3.0.4"},dependencies:{chalk:"^5.4.1",commander:"^13.1.0",conf:"^13.1.0",dotenv:"^16.4.7",prompts:"^2.4.2"}};import{Command as Ht,Option as Jt}from"commander";import{Argument as Tt}from"commander";var X=()=>new Tt("[workspace-path]","path to the workspace"),Q=X(),U=X().default(".");import Ft from"conf";import St from"chalk";var{red:Y,yellow:Z,green:tt,bold:C}=St;import{promises as w}from"node:fs";import{extname as Rt,join as K}from"node:path";async function E(r){return w.readFile(r,"utf8")}async function O(r,t){return w.writeFile(r,t,"utf8")}async function P(r,t,e=[]){try{await w.mkdir(t,{recursive:!0})}catch(s){if(s instanceof Error&&"code"in s&&s.code!=="EEXIST")throw s}let o=await w.readdir(r);await Promise.all(o.filter(s=>!e.includes(s)).map(async s=>{let i=K(r,s),a=K(t,s);(await w.stat(i)).isDirectory()?await P(i,a):await w.copyFile(i,a)}))}async function S(r){try{let o=(await w.readdir(r)).filter(i=>Rt(i).toLowerCase()===".json").map(async i=>{let a=K(r,i),c=await E(a);try{return JSON.parse(c)}catch(n){throw new Error(`Failed to parse JSON in file ${i}: ${n.message}`)}});return await Promise.all(o)}catch(t){throw new Error(`Error loading JSON files: ${t.message}`)}}import{spawnSync as et}from"node:child_process";import{existsSync as kt}from"node:fs";import{join as vt}from"node:path";async function rt(r,t,e){return kt(vt(e,".git"))?et("git",["pull"],{cwd:e,stdio:"inherit"}):et("git",["clone",r,e],{cwd:t,stdio:"inherit"}),Promise.resolve()}var z=class{log(t,e){let o=e?e(t):t;console.log(o)}error(t){this.log(t,Y)}warn(t){this.log(t,Z)}success(t){this.log(t,tt)}},p=new z;import{execSync as At}from"node:child_process";async function F(r,t){return At(r,{cwd:t,stdio:"inherit"})}import{createHash as It}from"node:crypto";import{access as ot,constants as Dt}from"node:fs/promises";import{join as Ut,resolve as Ot}from"node:path";function R(r){return Ot(r)}function V(r){let t=R(r);return It("md5").update(t).digest("hex").substring(0,10)}async function W(r){try{await ot(r);let t=V(r);return await ot(Ut(r,`${t}.json`),Dt.F_OK),!0}catch{return!1}}var Wt={workspacePath:{type:"string"},organization:{type:"string"},templatesRepository:{type:["string","null"]}},T;function st(r,t,e){return T=it(r),T.set("workspacePath",R(r)),T.set("organization",t),T.set("templatesRepository",e),T}function it(r){return T=new Ft({schema:Wt,cwd:R(r),configName:V(r)}),T}async function b(r){let t=r.trim();if(!await W(t))throw new Error("The given path is no valid workspace.");return it(t)}import{join as u}from"node:path";var nt="templates",g="config";var at="docker",ct="nginx";var pt="git-templates",mt="repositories",ut="servers",lt="use-cases",H="development";import{dirname as bt}from"node:path";import{fileURLToPath as $t}from"node:url";function gt(){let r=$t(import.meta.url);return bt(r)}var f=class r{constructor(t){this.config=t}static create(t){return new r(t)}getPackageTemplatesDir(){return u(this.#t(1),nt)}getGitTemplatesDir(){return u(this.#t(),g,pt)}getConfigDir(){return u(this.#t(),g)}getDockerDir(){return u(this.#t(),g,at)}getNginxDir(){return u(this.#t(),g,ct)}getServersDir(){return u(this.#t(),g,ut)}getUseCasesDir(){return u(this.#t(),g,lt)}getRepositoriesDir(){return u(this.#t(),g,mt)}getDevelopmentDir(){return u(this.#t(),g,H)}getWorkingDir(){return u(this.#t(),H)}#t(t=0){return t===0?this.getWorkspacePath():gt()}getWorkspacePath(){return this.config.get("workspacePath")}getTemplatesRepository(){return this.config.get("templatesRepository")}createRepositoryUrl(t,e){return`git@bitbucket.org:${t}/${e}.git`}async initWorkspace(){await this.syncTemplates(),await this.copyProxySetup(),await this.copyDevelopmentDirectory()}async syncTemplates(){let t=this.getPackageTemplatesDir();p.log(`Syncing templates from ${t}...`),await P(t,this.getWorkspacePath()),await this.syncRepositoryTemplates()}async syncRepositoryTemplates(){let t=this.getTemplatesRepository();if(t){let e=this.createRepositoryUrl(this.config.get("organization"),t);p.log(`Syncing templates from repository ${e}...`),await rt(e,this.getWorkspacePath(),this.getGitTemplatesDir()),await P(this.getGitTemplatesDir(),this.getConfigDir(),[".git"])}}async copyProxySetup(){await P(this.getNginxDir(),this.getWorkspacePath()),await P(this.getDockerDir(),this.getWorkspacePath())}async copyDevelopmentDirectory(){await P(this.getDevelopmentDir(),this.getWorkingDir())}};var k=class r{constructor(t){this.templatesAccess=t}static create(t){return new r(t)}async loadUseCases(...t){let e=["DISABLED",...t];return this.loadFiles().then(o=>o.map(s=>this.#t(s))).then(o=>o.filter(s=>!e.includes(s.state)))}async loadFiles(){return S(this.templatesAccess.getUseCasesDir())}#t(t){return{...t,description:t.description||"",state:t.state||"ENABLED"}}};var $=class r{static create(){return new r}executeFormula(t,e){try{let o=this.#t(t,e);return(0,eval)(o)}catch(o){throw new Error(`Error executing formula: ${o}`)}}#t(t,e){return`${Object.entries(e).reduce((s,[i,a])=>`${s}const ${i} = ${JSON.stringify(a)};`,"")}${t}`}};var N=class r{constructor(t,e){this.config=t;this.templatesAccess=e}static create(t,e){return new r(t,e)}async loadRepositories(){return this.loadFiles().then(t=>t.map(e=>this.#t(e)))}async loadFiles(){return S(this.templatesAccess.getRepositoriesDir())}#t(t){return{...t,alias:t.alias||t.name,url:t.url||this.templatesAccess.createRepositoryUrl(this.config.get("organization"),t.name),attributes:{type:"UNKNOWN",...t.attributes}}}};var _=class r{constructor(t){this.templatesAccess=t}static create(t){return new r(t)}async loadServers(){return this.loadFiles()}async loadFiles(){return S(this.templatesAccess.getServersDir())}};var M=class r{constructor(t,e,o){this.templatesAccess=t;this.serversRepository=e;this.repositoriesRepository=o}static create(t,e){return new r(e,_.create(e),N.create(t,e))}async createContext(t={}){return{...t,WORKSPACE_PATH:this.templatesAccess.getWorkspacePath(),WORKING_DIR:this.templatesAccess.getWorkingDir(),SERVERS:await this.serversRepository.loadServers(),REPOSITORIES:await this.repositoriesRepository.loadRepositories()}}};var y=class{constructor(t,e){this.scriptExecutor=t;this.templatesAccess=e}async execute(t,e){throw new Error("Method not implemented.")}};var B=class extends y{async execute(t,e){let{inputFile:o,outputFile:s,context:i}=t;if(!o)throw new Error("No input file provided.");if(!i?.name||!i?.value)throw new Error("Missing replacement target or value.");let a=this.scriptExecutor.executeFormula(o,e),c=await E(a),{name:n,value:l}=i,m=this.scriptExecutor.executeFormula(n,e).replace(/[.*+?^${}()|[\]\\]/g,"\\$&"),d=this.scriptExecutor.executeFormula(l,e),A=c.replace(new RegExp(`${m}=.*`),`${m}=${d}`),j=this.scriptExecutor.executeFormula(s||o,e);return await O(j,A),e}};import Gt from"prompts";import Nt from"prompts";function v(r){r.aborted&&(process.stdout.write("\x1B[?25h"),process.stdout.write(`
`),process.exit(1))}function h(r){return typeof r=="string"&&!!r.trim()||typeof r=="boolean"}async function _t(r,t,e,o={}){return Nt({onState:v,type:r,name:"entity",message:`Select the ${t}`,choices:e.filter(o.displayFilter||(()=>!0)).map(s=>({title:o.createTitle?o.createTitle(s):s.name,value:s.id}))}).then(({entity:s})=>s)}function Mt(r,t){let e=t.reduce((o,s)=>({...o,[s.id]:s}),{});if(typeof r=="string"){let o=e[r.trim()];if(o)return[o]}else{if(Array.isArray(r))return r.map(o=>e[o.trim()]);throw new Error(`Can find entity for value ${r}.`)}throw new Error(`Entity for selection ${C(r)} not found.`)}async function Bt(r,t,e,o,s={}){let i=h(e)&&typeof e=="string"?e:await _t(r,t,o,s);return Mt(i,o)}async function ft(r,t,e,o={}){let[s]=await Bt("select",r,t,e,o);return s}import Lt from"prompts";async function xt(r,t){return Lt({onState:v,type:r,name:"input",message:t,initial:r==="toggle"?!0:void 0,active:"yes",inactive:"no"}).then(({input:e})=>e)}async function I(r,t,e){return h(e)?e:xt(r,t)}async function J(r,t){let e=h(t)?t:await xt("text",r);if(h(e)&&typeof e=="string")return e.trim();throw Error("No input path provided.")}async function jt(r,t,e){return Gt({onState:v,type:r,name:"input",message:t,choices:e.map(({id:o,name:s})=>({title:s,value:o}))}).then(({input:o})=>o)}function Kt(r,t){let e=t.reduce((o,s)=>({...o,[s.id]:s}),{});if(typeof r=="string"){let o=e[r.trim()];if(o)return o}else{if(Array.isArray(r))return r.map(o=>e[o.trim()]);throw new Error(`Can find entity for value ${r}.`)}throw new Error(`Entity for selection ${C(r)} not found.`)}var L=class extends y{async execute(t,e){let{name:o,message:s,type:i,entities:a,entityKey:c}=t.context;if(!o||!s||!i)throw new Error("Prompt name, message or type missing.");let n;switch(i){case"select":case"multiselect":{let l=(c?e[c]:a)||[],m=await jt(i,s,l);n=Kt(m,l);break}default:{n=await I(i,s);break}}return{...e,[o]:n}}};import zt from"dotenv";var G=class extends y{async execute(t,e){let o={...e},s=`${this.templatesAccess.getWorkspacePath()}/services.env`,i=zt.parse(await E(s));Object.assign(o,i),Object.entries(t.context||{}).forEach(([j,Et])=>{o[j]=this.scriptExecutor.executeFormula(Et,o)});let{kcVersion:a,authServerUrl:c,authUser:n,authPassword:l,authTenant:m}=o,d=this.templatesAccess.getWorkspacePath(),A=`docker run         --pull=always         --env-file ${d}/.env         --mount type=bind,src="${d}/config/secret-templates",target="/secret-templates,readonly"         --mount type=bind,src="${d}/config/services-config",target="/output"         --rm -i ghcr.io/cycrilabs/keycloak-configurator:${a} export-secrets -s ${c} -u ${n} -p "${l}" -r ${m} -c //secret-templates -o //output`;return await F(A,this.templatesAccess.getWorkspacePath()),o}};var q={"custom-prompt":L,"generate-service-configuration":G,"change-env-var-value":B};var x=class r{constructor(t,e,o,s){this.templatesAccess=t;this.useCasesRepository=e;this.contextCreator=o;this.scriptExecutor=s}static create(t,e,o){return new r(e,k.create(e),M.create(t,e),o||$.create())}async run(t,e={}){if(typeof t=="string"){let s=(await this.useCasesRepository.loadUseCases()).find(({id:i})=>i===t);if(!s)throw new Error(`Use case not found: ${t}`);return await this.#t(s,e)}else return await this.#t(t,e)}async#t(t,e={}){let{name:o,description:s,steps:i}=t,a=await this.contextCreator.createContext(e);return p.log(`Running use case ${C(o)}...`),s&&p.log(`${s}`),i&&i.length!==0?(p.log("Executing steps..."),await this.#o(i,a)):a}async#o(t,e){let o={...e,STEPS:t};for(let s=0;s<t.length;s++){let i=t[s];p.log(`Step ${s+1}: ${i.description||""}`);let a=await this.#s(i,o);Object.assign(o,a)}return o}async#s(t,e){let o={...e,STEP:t},{inputFile:s,abortIf:i,skipIf:a,loop:c}=t;if(s){let n=this.scriptExecutor.executeFormula(s,o);o.INPUT=await E(n)}if(i&&this.scriptExecutor.executeFormula(i,o))throw new Error("Stopping because 'abortIf' formula is met.");if(a&&this.scriptExecutor.executeFormula(a,o))return p.log("Skipping step."),o;if(c){let n=this.scriptExecutor.executeFormula(c.list,o);if(!n||!Array.isArray(n))throw new Error(`List ${C(c.list)} not found in context.`);let l={...o};for(let m=0;m<n.length;m++){let d=n[m],A={...l,[c.name]:d};await this.#e(t,A)}return o}else return await this.#e(t,o)}async#e(t,e){switch(t.type){case"FORMULA":return await this.#i(t,e);case"COMMAND":return await this.#n(t,e);case"EXECUTOR":return await this.#a(t,e);case"PROMPT":return await this.#c(t,e);case"USE_CASE":return await this.#p(t,e);default:throw new Error(`Unknown step type ${t.type}. Stopping.`)}}async#i(t,e){if(!t.formula)throw new Error("Formula missing in step.");let o=this.scriptExecutor.executeFormula(t.formula,e);return t.outputFile&&typeof o=="string"&&await O(t.outputFile,o),{...e,[t.resultVariable||"STEP_RESULT"]:o}}async#n(t,e){if(!t.command)throw new Error("Command missing in step.");let o=this.scriptExecutor.executeFormula(t.command,e);return await F(o,this.templatesAccess.getWorkspacePath()),e}async#a(t,e){if(!t.executor||!q[t.executor])throw new Error("Executor missing or not found: "+t.executor);return this.#r(t.executor).execute(t,e)}async#c(t,e){return this.#r("custom-prompt").execute(t,e)}#r(t){return new q[t](this.scriptExecutor,this.templatesAccess)}async#p(t,e){if(!t.useCase)throw new Error("Use case missing in step.");let s=(await this.useCasesRepository.loadUseCases("INITIAL")).find(i=>i.id===t.useCase);if(!s)throw new Error(`Use case not found: ${t.useCase}`);return p.log("Starting to run references use case..."),await this.run(s,e),e}};async function Vt(r){return h(r)&&typeof r=="string"?r.trim():await I("toggle","Do you want to use a template repository?")?await I("text","Enter the name of the template repository"):null}async function yt(r,t){let e=await J("Path to the target workspace directory",r),o=R(e);if(await W(o))throw new Error("A workspace for the given path is already existing.");let i=await J("What is the name of your organization?"),a=await Vt(t.templatesRepository),c=st(o,i,a),n=f.create(c);await n.initWorkspace(),await x.create(c,n).run("init")}var qt=new Jt("--templates-repository <templatesRepository>","use a template repository"),ht=new Ht().name("init").description("initialize the workspace").addArgument(Q).addOption(qt).action(yt);import{Command as Xt,Option as Qt}from"commander";var Yt=new Qt("-u, --use-case [use-case]","execute the use case with the given name");async function Zt(r,t){let e=await b(r),o=f.create(e),s=x.create(e,o),a=await k.create(o).loadUseCases("INITIAL"),c=await ft("Use case",t.useCase,a,{createTitle:n=>`${n.name} (${n.id})`,displayFilter:n=>n.state!=="HIDDEN"});await s.run(c)}var dt=new Xt().name("run").description("run a use case in the workspace").addArgument(U).addOption(Yt).action(Zt);import{Command as te}from"commander";async function ee(r){let t=await b(r),e=f.create(t);await e.syncTemplates(),await x.create(t,e).run("sync")}var Ct=new te().name("sync").description("syncs the workspace templates with the package & configured repository").addArgument(U).action(ee);var wt=()=>process.exit(0);process.on("SIGINT",wt);process.on("SIGTERM",wt);process.on("uncaughtException",r=>{p.error(r.message),process.exit(1)});new re().name(D.name).description(D.description).version(D.version).addCommand(ht).addCommand(dt).addCommand(Ct).parseAsync().catch(r=>{p.error(r.message),process.exit(1)}).finally(()=>p.success("Finished execution."));
